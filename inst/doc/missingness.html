<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Marjolein Fokkema" />


<title>Dealing with missing data in fitting prediction rule ensembles</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Dealing with missing data in fitting
prediction rule ensembles</h1>
<h4 class="author">Marjolein Fokkema</h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>To deal with missing data in parametric models, multiple imputation
is the golden standard (Schafer &amp; Graham, 2002). With GLMs, the
models fitted on each imputed dataset can then be pooled. For
non-parametric methods and specifically prediction rule ensembles, the
jury is still out on how to best deal with missing data. There are
several possible approaches:</p>
<ul>
<li><p>Listwise deletion. Although the default in <code>pre()</code>, it
is certainly the least favorable option.</p></li>
<li><p>Single imputation: Perform only a single imputation and fit a
prediction rule ensemble on this single dataset. This is likely better
than listwise deletion, but likely inferior to multiple imputation. The
main advantage is that a PRE can be fit as usual.</p></li>
<li><p>Multiple imputation followed by pooling. This approach takes
multiple imputed datasets and fits a separate prediction rule ensemble
to each of the imputed datasets, which are aggregated to form a final
ensemble. The main disadvantage is that this yields an ensemble of
ensembles, which will be (much) more complex and thus less interpretable
than a single PRE.</p></li>
<li><p>Multiple imputation followed by stacking. This approach stacks
the multiple imputed datasets and fits a single prediction rule ensemble
to this dataset. Rule generation and estimation of the final model can
be adjusted to counter the artificial inflation of sample size. The main
advantage is that it yields a single PRE, while treating missing data in
an optimal manner.</p></li>
</ul>
<p>An alternative, would be the Missing-In-Attributes approach for rule
generation, followed by mean imputation for the final model. According
to Josse et al. (2019), mean imputation and the Missing-In-Attributes
approaches perform well from a prediction perspective and are
computationally inexpensive. This will be implemented in future versions
of package <strong><code>pre</code></strong>.</p>
<p>Below, we provide examples for the four approaches described
above.</p>
</div>
<div id="example-predicting-wind-speed" class="section level2">
<h2>Example: Predicting wind speed</h2>
<p>For the examples, we will be predicting Wind speeds using the
<code>airquality</code> dataset (we focus on predicting the
<code>wind</code> variable, because it does not have missing values,
while variables <code>Ozone</code> and <code>Solar.R</code> do):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">head</span>(airquality)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">nrow</span>(airquality)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;mice&quot;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">md.pattern</span>(airquality, <span class="at">rotate.names =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="listwise-deletion" class="section level2">
<h2>Listwise Deletion</h2>
<p>This option, although not recommended, is the default of function
<code>pre()</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;pre&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>airq.ens <span class="ot">&lt;-</span> <span class="fu">pre</span>(Wind <span class="sc">~</span>., <span class="at">data =</span> airquality)</span></code></pre></div>
<pre><code>## Warning in pre(Wind ~ ., data = airquality): Some observations have missing values and have been removed from the data. New sample size is 111.</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>airq.ens</span></code></pre></div>
<pre><code>## 
## Final ensemble with cv error within 1se of minimum: 
## 
##   lambda =  0.5076221
##   number of terms = 2
##   mean cv error (se) = 9.955139 (1.553628)
## 
##   cv error type : Mean-Squared Error
## 
##          rule   coefficient           description
##   (Intercept)   9.034190233                     1
##         rule8   1.743533723           Ozone &lt;= 45
##         Ozone  -0.006180118  6.75 &lt;= Ozone &lt;= 119</code></pre>
<p>With listwise deletion, only 111 out of 153 observations are
retained. We obtain a rather sparse ensemble.</p>
</div>
<div id="single-imputation" class="section level2">
<h2>Single Imputation</h2>
<p>Here we apply single imputation by replacing missing values with the
mean:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>imp0 <span class="ot">&lt;-</span> airquality</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>imp0<span class="sc">$</span>Solar.R[<span class="fu">is.na</span>(imp0<span class="sc">$</span>Solar.R)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Solar.R, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>imp0<span class="sc">$</span>Ozone[<span class="fu">is.na</span>(imp0<span class="sc">$</span>Ozone)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Ozone, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>airq.ens.imp0 <span class="ot">&lt;-</span> <span class="fu">pre</span>(Wind <span class="sc">~</span>., <span class="at">data =</span> imp0)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>airq.ens.imp0</span></code></pre></div>
<pre><code>## 
## Final ensemble with cv error within 1se of minimum: 
## 
##   lambda =  0.2751573
##   number of terms = 5
##   mean cv error (se) = 9.757455 (0.7622478)
## 
##   cv error type : Mean-Squared Error
## 
##          rule  coefficient                 description
##   (Intercept)  10.48717592                           1
##         rule2   1.18133248                 Ozone &lt;= 45
##        rule48  -0.56453456  Temp &gt; 72 &amp; Solar.R &lt;= 258
##        rule28  -0.51357673      Temp &gt; 73 &amp; Ozone &gt; 22
##         Ozone  -0.01910646         7 &lt;= Ozone &lt;= 115.6
##        rule40   0.01440472                  Temp &lt;= 81</code></pre>
<p>We obtain a larger number of rules, and slightly lower
cross-validated mean squared error. However, this model cannot really be
compared with the listwise deletion model, because they are computed
over different sets of observations.</p>
</div>
<div id="multiple-imputation" class="section level2">
<h2>Multiple Imputation</h2>
<p>We first perform multiple imputation by chained equations, using the
predictive mean matching method. We generate 5 imputed datasets:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>imp <span class="ot">&lt;-</span> <span class="fu">mice</span>(airquality, <span class="at">m =</span> <span class="dv">5</span>, <span class="at">printFlag =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>We create a <code>list</code> with imputed datasets:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>imp1 <span class="ot">&lt;-</span> <span class="fu">complete</span>(imp, <span class="at">action =</span> <span class="st">&quot;all&quot;</span>, <span class="at">include =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>To deal with imputed data, we have two options: <em>Stacking</em> the
imputed datasets or <em>pooling</em> the resulting ensembles. The former
is likely most beneficial for retaining interpretability and therefore
an experimental (!) version has been implemented in package
<strong><code>pre</code></strong>.</p>
<div id="stacking-imputed-datasets" class="section level3">
<h3>Stacking imputed datasets</h3>
<p>Function <code>mi_pre</code> implements a so-called <em>stacking</em>
approach (see also Wood et al., 2008), where imputed datasets are
combined into one large dataset. In addition to adjustments of the
sampling procedures, adjustments to observation weight are made to
counter the artificial inflation of sample size. Function
<code>mi_pre</code> takes a list of imputed datasets as input data,
because it is assumed imputation has already been performed.</p>
<p>Although the option to use the fraction of complete data for
computing observation weight is provided through argument
<code>compl_frac</code> of function <code>mi_pre</code>, users are not
advised to use it. For example, Du et al. (2022) write: “An alternative
weight specification, proposed in Wan et al. (2015), is <span class="math inline">\(o_i = \frac{f_i}{D}\)</span>, where <span class="math inline">\(f_i\)</span> is the number of observed predictors
out of the total number of predictors for subject <span class="math inline">\(i\)</span> […] upweighting subjects with less
missingness and downweighting subjects with more missingness can, in
some sense, be viewed as making the optimization more like complete-case
analysis, which might be problematic for Missing at Random (MAR) and
Missing not at Random (MNAR) scenarios.”</p>
<p>We fit a rule ensemble to the imputed data using stacking:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>airq.ens.sta <span class="ot">&lt;-</span> <span class="fu">mi_pre</span>(Wind <span class="sc">~</span> . , <span class="at">data =</span> imp1)</span></code></pre></div>
<p>All <code>S3</code> methods for objects of class <code>pre</code> are
also applicable to the ensembles resulting from application of function
<code>mi_pre</code>, e.g.:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">summary</span>(airq.ens.sta)</span></code></pre></div>
<pre><code>## 
## Final ensemble with cv error within 1se of minimum: 
## 
##   lambda =  0.3397143
##   number of terms = 6
##   mean cv error (se) = 9.821413 (1.103229)
## 
##   cv error type : Mean-Squared Error</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>coefs <span class="ot">&lt;-</span> <span class="fu">coef</span>(airq.ens.sta)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>coefs[coefs<span class="sc">$</span>coefficient <span class="sc">!=</span> <span class="dv">0</span>, ]</span></code></pre></div>
<pre><code>##           rule coefficient       description
## 49 (Intercept)  9.44439871                 1
## 6        rule6  1.29750892       Ozone &lt;= 45
## 20      rule23  0.17877849        Temp &lt;= 73
## 2        rule2  0.15142541       Ozone &lt;= 21
## 5        rule5  0.13556989       Ozone &lt;= 47
## 10      rule11  0.03251171       Ozone &lt;= 52
## 50       Ozone -0.01401860 7 &lt;= Ozone &lt;= 118</code></pre>
<p>Computation of partial dependence plots can become computationally
prohibitive, especially with multiply-imputed data. To reduce
computational load, function <code>mi_mean</code> computes the average
imputed dataset, which can then be supplied to the <code>newdata</code>
arguments of functions <code>singleplot</code> or <code>pairplot</code>
to speed up computation of partial dependence plots:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>newdata <span class="ot">&lt;-</span> <span class="fu">mi_mean</span>(imp1)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">singleplot</span>(airq.ens.sta, <span class="at">newdata =</span> newdata, <span class="at">varname =</span> <span class="st">&quot;Ozone&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">pairplot</span>(airq.ens.sta, <span class="at">newdata =</span> newdata, <span class="at">varnames =</span> <span class="fu">c</span>(<span class="st">&quot;Ozone&quot;</span>, <span class="st">&quot;Solar.R&quot;</span>))</span></code></pre></div>
<pre><code>## Loading required namespace: interp</code></pre>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="pooling" class="section level3">
<h3>Pooling</h3>
<p>To apply pooling, we create a custom function that fits PREs to
several datasets contained in a list:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>pre.agg <span class="ot">&lt;-</span> <span class="cf">function</span>(datasets, ...) {</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(datasets)) {</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>    result[[i]] <span class="ot">&lt;-</span> <span class="fu">pre</span>(datasets[[i]], ...)</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>  }</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>  result</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>}</span></code></pre></div>
<p>We apply the new function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>airq.agg <span class="ot">&lt;-</span> <span class="fu">pre.agg</span>(imp1, <span class="at">formula =</span> Wind <span class="sc">~</span> .)</span></code></pre></div>
<p>Note that we can used the ellipsis (<code>...</code>) to pass
arguments to <code>pre</code> (see <code>?pre</code> for an overview of
arguments that can be specified).</p>
<p>We now define <code>print</code>, <code>summary</code>,
<code>predict</code> and <code>coef</code> methods to extract results
from the fitted ensemble. Again, we can use the ellipsis
(<code>...</code>) to pass arguments to the <code>print</code>,
<code>summary</code>, <code>predict</code> and <code>coef</code> methods
of function <code>pre</code> (see e.g., <code>?pre:::print.pre</code>
for more info):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>print.agg <span class="ot">&lt;-</span> <span class="cf">function</span>(object, ...) {</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>  <span class="fu">sink</span>(<span class="st">&quot;NULL&quot;</span>)</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(object)) {</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    result[[i]] <span class="ot">&lt;-</span> <span class="fu">print</span>(object[[i]], ...)</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>  }</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>  <span class="fu">sink</span>()</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>  <span class="fu">print</span>(result)</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>}</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a><span class="fu">print.agg</span>(airq.agg) <span class="do">## results suppressed for space considerations</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>summary.agg <span class="ot">&lt;-</span> <span class="cf">function</span>(object, ...) {</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(object)) <span class="fu">summary</span>(object[[i]], ...)</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>}</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a><span class="fu">summary.agg</span>(airq.agg) <span class="do">## results suppressed for space considerations</span></span></code></pre></div>
<p>For averaging over predictions, there is only one option for
continuous outcomes. For non-continuous outcomes, we can average over
the linear predictor, or over the predicted values on the scale of the
response. I am not sure which would be more appropriate; the resulting
predicted values will not be identical, but highly correlated,
though.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>predict.agg <span class="ot">&lt;-</span> <span class="cf">function</span>(object, newdata, ...) {</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  <span class="fu">rowMeans</span>(<span class="fu">sapply</span>(object, predict, <span class="at">newdata =</span> newdata, ...))</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>}</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>agg_preds <span class="ot">&lt;-</span> <span class="fu">predict.agg</span>(airq.agg, <span class="at">newdata =</span> airquality[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, ])</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>agg_preds</span></code></pre></div>
<pre><code>##        1        2        3        4 
## 10.42757 10.59272 10.93324 11.00302</code></pre>
<p>Finally, the <code>coef</code> method should return the averaged /
aggregated final PRE. That is, it returns:</p>
<ol style="list-style-type: decimal">
<li><p>One averaged intercept;</p></li>
<li><p>All rules and linear terms, with their coefficients scaled by the
number of datasets;</p></li>
<li><p>In presence of identical rules and linear terms, it aggregates
those rules and their coefficients into one rule / term, and adds
together the scaled coefficients.</p></li>
</ol>
<p>Note that linear terms of the same predictors, which obtained
different winsorizing points across imputed datasets will be retained
seperately and will not be aggregated. Note also that the labels of
rules and variables may overlap between different datasets (e.g., the
label <code>rule 12</code> may appear multiple times in the aggregated
ensemble, but each <code>rule 12</code> will have different
conditions).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>coef.agg <span class="ot">&lt;-</span> <span class="cf">function</span>(object, ...) {</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  coefs <span class="ot">&lt;-</span> <span class="fu">coef</span>(object[[<span class="dv">1</span>]], ...)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  coefs <span class="ot">&lt;-</span> coefs[coefs<span class="sc">$</span>coefficient <span class="sc">!=</span> <span class="dv">0</span>, ]</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="fu">length</span>(object)) {</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    coefs_tmp <span class="ot">&lt;-</span> <span class="fu">coef</span>(object[[i]], ...)</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>    coefs <span class="ot">&lt;-</span> <span class="fu">rbind</span>(coefs, coefs_tmp[coefs_tmp<span class="sc">$</span>coefficient <span class="sc">!=</span> <span class="dv">0</span>, ])</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>  }</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>  <span class="do">## Divide coefficients by the number of datasets:</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>  coefs<span class="sc">$</span>coefficient <span class="ot">&lt;-</span> coefs<span class="sc">$</span>coefficient <span class="sc">/</span> <span class="fu">length</span>(object)</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>  <span class="do">## Identify identical rules:</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>  duplicates <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">duplicated</span>(coefs<span class="sc">$</span>description))</span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> duplicates) {</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>    first_match <span class="ot">&lt;-</span> <span class="fu">which</span>(coefs<span class="sc">$</span>description <span class="sc">==</span> coefs<span class="sc">$</span>description[i])[<span class="dv">1</span>]</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>    <span class="do">## Add the coefficients:</span></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a>    coefs<span class="sc">$</span>coefficient[first_match] <span class="ot">&lt;-</span> </span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>      coefs<span class="sc">$</span>coefficient[first_match] <span class="sc">+</span> coefs<span class="sc">$</span>coefficient[i]</span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a>  }</span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a>  <span class="do">## Remove duplicates:</span></span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(duplicates) <span class="sc">&gt;</span> <span class="dv">0</span>) coefs <span class="ot">&lt;-</span> coefs[<span class="sc">-</span>duplicates, ]</span>
<span id="cb23-20"><a href="#cb23-20" tabindex="-1"></a>  <span class="do">## Check if there are- duplicate linear terms left and repeat:</span></span>
<span id="cb23-21"><a href="#cb23-21" tabindex="-1"></a>  duplicates <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">duplicated</span>(coefs<span class="sc">$</span>rule))</span>
<span id="cb23-22"><a href="#cb23-22" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> duplicates) {</span>
<span id="cb23-23"><a href="#cb23-23" tabindex="-1"></a>    first_match <span class="ot">&lt;-</span> <span class="fu">which</span>(coefs<span class="sc">$</span>rule <span class="sc">==</span> coefs<span class="sc">$</span>rule[i])[<span class="dv">1</span>]</span>
<span id="cb23-24"><a href="#cb23-24" tabindex="-1"></a>    coefs<span class="sc">$</span>coefficient[first_match] <span class="ot">&lt;-</span> </span>
<span id="cb23-25"><a href="#cb23-25" tabindex="-1"></a>      coefs<span class="sc">$</span>coefficient[first_match] <span class="sc">+</span> coefs<span class="sc">$</span>coefficient[i]</span>
<span id="cb23-26"><a href="#cb23-26" tabindex="-1"></a>  }</span>
<span id="cb23-27"><a href="#cb23-27" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(duplicates) <span class="sc">&gt;</span> <span class="dv">0</span>) coefs <span class="ot">&lt;-</span> coefs[<span class="sc">-</span>duplicates, ]</span>
<span id="cb23-28"><a href="#cb23-28" tabindex="-1"></a>  <span class="do">## Return results:</span></span>
<span id="cb23-29"><a href="#cb23-29" tabindex="-1"></a>  coefs</span>
<span id="cb23-30"><a href="#cb23-30" tabindex="-1"></a>}</span>
<span id="cb23-31"><a href="#cb23-31" tabindex="-1"></a><span class="fu">coef.agg</span>(airq.agg)</span></code></pre></div>
<pre><code>##           rule  coefficient                 description
## 65 (Intercept)  9.433571984                           1
## 29      rule32  0.097328032      Temp &gt; 73 &amp; Ozone &gt; 23
## 3        rule3  0.968746033                 Ozone &lt;= 45
## 7        rule7  0.040507812 Ozone &gt; 14 &amp; Solar.R &lt;= 238
## 66       Ozone -0.006089757         7 &lt;= Ozone &lt;= 115.6
## 6        rule6  0.074835353                 Ozone &lt;= 59
## 25      rule26 -0.067771974      Temp &gt; 63 &amp; Ozone &gt; 14
## 17      rule17 -0.038092316      Temp &gt; 75 &amp; Ozone &gt; 47
## 1        rule1  0.090749273                 Ozone &lt;= 21
## 58      rule62 -0.277510244 Ozone &gt; 45 &amp; Solar.R &lt;= 275
## 36      rule39 -0.046938032 Ozone &gt; 14 &amp; Solar.R &lt;= 201
## 40      rule43 -0.035213431  Temp &gt; 72 &amp; Solar.R &lt;= 255
## 51       rule5  0.031821453                 Ozone &lt;= 52
## 10      rule10  0.070056367                  Temp &lt;= 73
## 19      rule22  0.066962331                 Ozone &lt;= 63
## 14      rule15  0.001044073 Ozone &lt;= 45 &amp; Solar.R &gt; 212</code></pre>
<p>We have obtained a final ensemble of 15 terms.</p>
</div>
</div>
<div id="comparing-accuracy-and-sparsity" class="section level2">
<h2>Comparing accuracy and sparsity</h2>
<p>We compare performance using 10-fold cross validation. We evaluate
predictive accuracy and the number of selected rules. We only evaluate
accuracy for observations that have no missing values.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>fold_ids <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>k, <span class="at">size =</span> <span class="fu">nrow</span>(airquality), <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>observed <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>k) {</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  <span class="do">## Separate training and test data</span></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>  test <span class="ot">&lt;-</span> airquality[fold_ids <span class="sc">==</span> i, ]</span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>  test <span class="ot">&lt;-</span> test[<span class="sc">!</span><span class="fu">is.na</span>(test<span class="sc">$</span>Ozone), ]</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>  test <span class="ot">&lt;-</span> test[<span class="sc">!</span><span class="fu">is.na</span>(test<span class="sc">$</span>Solar.R), ]</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>  observed <span class="ot">&lt;-</span> <span class="fu">c</span>(observed, test<span class="sc">$</span>Wind)</span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>}  </span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a>preds <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(observed)</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>preds<span class="sc">$</span>LWD <span class="ot">&lt;-</span> preds<span class="sc">$</span>SI <span class="ot">&lt;-</span> preds<span class="sc">$</span>MI <span class="ot">&lt;-</span> preds<span class="sc">$</span>observed</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a>nterms <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="at">nrow =</span> k, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a><span class="fu">colnames</span>(nterms) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;LWD&quot;</span>, <span class="st">&quot;SI&quot;</span>, <span class="st">&quot;MI&quot;</span>)</span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>row <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>k) {</span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a>  <span class="cf">if</span> (i <span class="sc">&gt;</span> <span class="dv">1</span>) row <span class="ot">&lt;-</span> row <span class="sc">+</span> <span class="fu">nrow</span>(test)</span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a>  </span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a>  <span class="do">## Separate training and test data</span></span>
<span id="cb25-25"><a href="#cb25-25" tabindex="-1"></a>  train <span class="ot">&lt;-</span> airquality[fold_ids <span class="sc">!=</span> i, ]</span>
<span id="cb25-26"><a href="#cb25-26" tabindex="-1"></a>  test <span class="ot">&lt;-</span> airquality[fold_ids <span class="sc">==</span> i, ]</span>
<span id="cb25-27"><a href="#cb25-27" tabindex="-1"></a>  test <span class="ot">&lt;-</span> test[<span class="sc">!</span><span class="fu">is.na</span>(test<span class="sc">$</span>Ozone), ]</span>
<span id="cb25-28"><a href="#cb25-28" tabindex="-1"></a>  test <span class="ot">&lt;-</span> test[<span class="sc">!</span><span class="fu">is.na</span>(test<span class="sc">$</span>Solar.R), ]</span>
<span id="cb25-29"><a href="#cb25-29" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" tabindex="-1"></a>  <span class="do">## Fit and evaluate listwise deletion</span></span>
<span id="cb25-31"><a href="#cb25-31" tabindex="-1"></a>  premod <span class="ot">&lt;-</span> <span class="fu">pre</span>(Wind <span class="sc">~</span> ., <span class="at">data =</span> train)</span>
<span id="cb25-32"><a href="#cb25-32" tabindex="-1"></a>  preds<span class="sc">$</span>LWD[row<span class="sc">:</span>(row<span class="sc">+</span><span class="fu">nrow</span>(test)<span class="sc">-</span><span class="dv">1</span>)] <span class="ot">&lt;-</span> <span class="fu">predict</span>(premod, <span class="at">newdata =</span> test)</span>
<span id="cb25-33"><a href="#cb25-33" tabindex="-1"></a>  tmp <span class="ot">&lt;-</span> <span class="fu">print</span>(premod)</span>
<span id="cb25-34"><a href="#cb25-34" tabindex="-1"></a>  nterms[i, <span class="st">&quot;LWD&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">nrow</span>(tmp) <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb25-35"><a href="#cb25-35" tabindex="-1"></a>  </span>
<span id="cb25-36"><a href="#cb25-36" tabindex="-1"></a>  <span class="do">## Fit and evaluate single imputation</span></span>
<span id="cb25-37"><a href="#cb25-37" tabindex="-1"></a>  imp0 <span class="ot">&lt;-</span> train</span>
<span id="cb25-38"><a href="#cb25-38" tabindex="-1"></a>  imp0<span class="sc">$</span>Solar.R[<span class="fu">is.na</span>(imp0<span class="sc">$</span>Solar.R)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Solar.R, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb25-39"><a href="#cb25-39" tabindex="-1"></a>  imp0<span class="sc">$</span>Ozone[<span class="fu">is.na</span>(imp0<span class="sc">$</span>Ozone)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Ozone, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb25-40"><a href="#cb25-40" tabindex="-1"></a>  premod.imp0 <span class="ot">&lt;-</span> <span class="fu">pre</span>(Wind <span class="sc">~</span>., <span class="at">data =</span> imp0)</span>
<span id="cb25-41"><a href="#cb25-41" tabindex="-1"></a>  imp1 <span class="ot">&lt;-</span> test</span>
<span id="cb25-42"><a href="#cb25-42" tabindex="-1"></a>  imp1<span class="sc">$</span>Solar.R[<span class="fu">is.na</span>(imp1<span class="sc">$</span>Solar.R)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Solar.R, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb25-43"><a href="#cb25-43" tabindex="-1"></a>  imp1<span class="sc">$</span>Ozone[<span class="fu">is.na</span>(imp1<span class="sc">$</span>Ozone)] <span class="ot">&lt;-</span> <span class="fu">mean</span>(imp0<span class="sc">$</span>Ozone, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb25-44"><a href="#cb25-44" tabindex="-1"></a>  preds<span class="sc">$</span>SI[row<span class="sc">:</span>(row<span class="sc">+</span><span class="fu">nrow</span>(test)<span class="sc">-</span><span class="dv">1</span>)] <span class="ot">&lt;-</span> <span class="fu">predict</span>(premod.imp0, <span class="at">newdata =</span> imp1)  </span>
<span id="cb25-45"><a href="#cb25-45" tabindex="-1"></a>  tmp <span class="ot">&lt;-</span> <span class="fu">print</span>(premod.imp0)</span>
<span id="cb25-46"><a href="#cb25-46" tabindex="-1"></a>  nterms[i, <span class="st">&quot;SI&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">nrow</span>(tmp) <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb25-47"><a href="#cb25-47" tabindex="-1"></a>  </span>
<span id="cb25-48"><a href="#cb25-48" tabindex="-1"></a>  <span class="do">## Perform multiple imputation</span></span>
<span id="cb25-49"><a href="#cb25-49" tabindex="-1"></a>  imp <span class="ot">&lt;-</span> <span class="fu">mice</span>(train, <span class="at">m =</span> <span class="dv">5</span>)</span>
<span id="cb25-50"><a href="#cb25-50" tabindex="-1"></a>  imp1 <span class="ot">&lt;-</span> <span class="fu">complete</span>(imp, <span class="at">action =</span> <span class="st">&quot;all&quot;</span>, <span class="at">include =</span> <span class="cn">FALSE</span>)</span>
<span id="cb25-51"><a href="#cb25-51" tabindex="-1"></a>  airq.agg <span class="ot">&lt;-</span> <span class="fu">pre.agg</span>(imp1, <span class="at">formula =</span> Wind <span class="sc">~</span> .)</span>
<span id="cb25-52"><a href="#cb25-52" tabindex="-1"></a>  preds<span class="sc">$</span>MI[row<span class="sc">:</span>(row<span class="sc">+</span><span class="fu">nrow</span>(test)<span class="sc">-</span><span class="dv">1</span>)] <span class="ot">&lt;-</span> <span class="fu">predict.agg</span>(airq.agg, <span class="at">newdata =</span> test)</span>
<span id="cb25-53"><a href="#cb25-53" tabindex="-1"></a>  nterms[i, <span class="st">&quot;MI&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">nrow</span>(<span class="fu">coef.agg</span>(airq.agg)) <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb25-54"><a href="#cb25-54" tabindex="-1"></a></span>
<span id="cb25-55"><a href="#cb25-55" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">sapply</span>(preds, <span class="cf">function</span>(x) <span class="fu">mean</span>((preds<span class="sc">$</span>observed <span class="sc">-</span> x)<span class="sc">^</span><span class="dv">2</span>)) <span class="do">## MSE</span></span></code></pre></div>
<pre><code>##  observed        MI        SI       LWD 
##  0.000000  9.462657 10.087872  9.824913</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">sapply</span>(preds, <span class="cf">function</span>(x) <span class="fu">sd</span>((preds<span class="sc">$</span>observed <span class="sc">-</span> x)<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">nrow</span>(preds))) <span class="do">## SE of MSE</span></span></code></pre></div>
<pre><code>## observed       MI       SI      LWD 
## 0.000000 1.472118 1.538254 1.499660</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">var</span>(preds<span class="sc">$</span>observed) <span class="do">## benchmark: Predict mean for all</span></span></code></pre></div>
<pre><code>## [1] 12.65732</code></pre>
<p>Interestingly, we see that all three methods yield similar
predictions and accuracy, and explain about 20% of variance in the
response. Multiple imputation performed best, followed by listwise
deletion, followed by single imputation. Taking into account the
standard errors, however, these differences are not significant. Also,
this simple evaluation on only a single dataset should not be taken too
seriously. The better performance of multiple imputation does come at
the cost of increased complexity:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">boxplot</span>(nterms, <span class="at">main =</span> <span class="st">&quot;Number of selected terms </span><span class="sc">\n</span><span class="st">per missing-data method&quot;</span>,</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>        <span class="at">cex.main =</span> .<span class="dv">8</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>In line with findings of Josse et al. (2019), we expect MIA to work
better for rules than mean imputation. In future versions of package
<strong><code>pre</code></strong>, we plan to implement MIA (for the
rules) and combine it with mean imputation (for the linear terms).</p>
</div>
<div id="session-info" class="section level2">
<h2>Session info</h2>
<p>In case you obtained different results, these results were obtained
using the following:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code></pre></div>
<pre><code>## R version 4.3.1 (2023-06-16 ucrt)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 19045)
## 
## Matrix products: default
## 
## 
## locale:
## [1] LC_COLLATE=C                       LC_CTYPE=Dutch_Netherlands.utf8   
## [3] LC_MONETARY=Dutch_Netherlands.utf8 LC_NUMERIC=C                      
## [5] LC_TIME=Dutch_Netherlands.utf8    
## 
## time zone: Europe/Amsterdam
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] pre_1.0.7   mice_3.16.0
## 
## loaded via a namespace (and not attached):
##  [1] sass_0.4.7         utf8_1.2.3         generics_0.1.3     tidyr_1.3.0       
##  [5] shape_1.4.6        stringi_1.7.12     lattice_0.21-8     inum_1.0-5        
##  [9] plotmo_3.6.2       lme4_1.1-35.1      digest_0.6.31      magrittr_2.0.3    
## [13] mitml_0.4-5        evaluate_0.23      grid_4.3.1         iterators_1.0.14  
## [17] mvtnorm_1.2-3      fastmap_1.1.1      foreach_1.5.2      jomo_2.7-6        
## [21] jsonlite_1.8.4     glmnet_4.1-8       Matrix_1.6-2       nnet_7.3-19       
## [25] backports_1.4.1    Formula_1.2-5      survival_3.5-5     purrr_1.0.1       
## [29] fansi_1.0.4        codetools_0.2-19   jquerylib_0.1.4    cli_3.6.0         
## [33] rlang_1.1.1        splines_4.3.1      plotrix_3.8-4      cachem_1.0.8      
## [37] yaml_2.3.7         pan_1.9            tools_4.3.1        deldir_1.0-9      
## [41] MatrixModels_0.5-3 earth_5.3.2        nloptr_2.0.3       minqa_1.2.6       
## [45] dplyr_1.1.2        interp_1.1-4       boot_1.3-28.1      broom_1.0.5       
## [49] rpart_4.1.19       vctrs_0.6.3        R6_2.5.1           lifecycle_1.0.4   
## [53] stringr_1.5.1      libcoin_1.0-10     MASS_7.3-60        partykit_1.2-20   
## [57] pkgconfig_2.0.3    pillar_1.9.0       bslib_0.5.1        TeachingDemos_2.12
## [61] glue_1.6.2         Rcpp_1.0.10        highr_0.10         xfun_0.41         
## [65] tibble_3.2.1       tidyselect_1.2.0   rstudioapi_0.15.0  knitr_1.45        
## [69] htmltools_0.5.7    nlme_3.1-162       rmarkdown_2.25     compiler_4.3.1</code></pre>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Du, J., Boss, J., Han, P., Beesley, L. J., Kleinsasser, M., Goutman,
S.A., … &amp; Mukherjee, B. (2022). Variable selection with
multiply-imputed datasets: choosing between stacked and grouped methods.
<em>Journal of Computational and Graphical Statistics, 31</em>(4),
1063-1075. </p>
<p>Josse, J., Prost, N., Scornet, E., &amp; Varoquaux, G. (2019). On the
consistency of supervised learning with missing values. <em>arXiv
preprint arXiv:1902.06931</em>. <a href="https://arxiv.org/abs/1902.06931" class="uri">https://arxiv.org/abs/1902.06931</a></p>
<p>Miles, A. (2016). Obtaining predictions from models fit to multiply
imputed data. <em>Sociological Methods &amp; Research, 45</em>(1),
175-185. </p>
<p>Schafer, J. L., &amp; Graham, J. W. (2002). Missing data: our view of
the state of the art. <em>Psychological Methods, 7</em>(2), 147. </p>
<p>Wood, A. M., White, I. R., &amp; Royston, P. (2008). How should
variable selection be performed with multiply imputed data?
<em>Statistics in Medicine, 27</em>(17), 3227-3246. </p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
